# Entities and Resolvers

## Overview

Viaduct uses two resolver types to build GraphQL APIs: **Node Resolvers** fetch objects by ID, and **Field Resolvers** compute individual fields. Understanding their responsibilities is key to building efficient APIs.

## Navigation

- Prerequisites: [Main Guide](../../viaduct.md)
- Related: [Queries](queries.md), [GlobalIDs](../gotchas/global-ids.md)
- Next Steps: [Mutations](mutations.md), [Relationships](relationships.md)

## Node Types

Any type implementing the `Node` interface is resolvable by GlobalID. Add `@resolver` to the type to generate `NodeResolvers.TypeName`:

```graphql
interface Node {
  id: ID!
}

# @resolver on the type generates NodeResolvers.User
type User implements Node @resolver @scope(to: ["default"]) {
  id: ID!
  firstName: String
  lastName: String
  email: String
  displayName: String @resolver  # Computed field
}
```

## Node Resolvers

Viaduct generates a base class for each Node type with `@resolver`:

```kotlin
// Generated by Viaduct
object NodeResolvers {
    abstract class User {
        open suspend fun resolve(ctx: Context): User = throw NotImplementedError()
        open suspend fun batchResolve(contexts: List<Context>): List<FieldValue<User>> = throw NotImplementedError()

        class Context: NodeExecutionContext<User>
    }
}
```

### Implementation

```kotlin
@Resolver
class UserNodeResolver @Inject constructor(
    private val userService: UserServiceClient
) : NodeResolvers.User() {

    override suspend fun resolve(ctx: Context): User {
        // ctx.id is GlobalID<User>
        val data = userService.fetch(ctx.id.internalID)

        return User.Builder(ctx)
            .firstName(data.firstName)
            .lastName(data.lastName)
            .email(data.email)
            .build()
    }
}
```

### Context Properties

The `Context` object provides:

| Property | Type | Description |
|----------|------|-------------|
| `id` | `GlobalID<User>` | The ID of the node to resolve |
| `id.internalID` | `String` | The internal ID (UUID) for database queries |
| `selections()` | `SelectionSet<User>` | Fields requested in the query |

### Responsibility Set

Node resolvers are responsible for **all fields without `@resolver`**:

```graphql
type User implements Node {
  id: ID!              # NOT in responsibility set (it's the input)
  firstName: String    # IN responsibility set
  lastName: String     # IN responsibility set
  displayName: String @resolver  # NOT in responsibility set
}
```

**Important**: Don't set fields with `@resolver` in your node resolver - they have their own resolvers.

## Field Resolvers

Fields with `@resolver` directive get their own resolvers:

```graphql
type User implements Node {
  id: ID!
  firstName: String
  lastName: String
  displayName: String @resolver  # This field gets a Field Resolver
}
```

### Generated Base Class

```kotlin
// Generated by Viaduct
object UserResolvers {
    abstract class DisplayName {
        open suspend fun resolve(ctx: Context): String? = throw NotImplementedError()

        class Context: FieldExecutionContext<User, Query, NoArguments, NotComposite>
    }
}
```

### Implementation with Required Selection Set

```kotlin
@Resolver("fragment _ on User { firstName lastName }")
class UserDisplayNameResolver : UserResolvers.DisplayName() {

    override suspend fun resolve(ctx: Context): String? {
        // Access parent object fields via ctx.objectValue
        val fn = ctx.objectValue.getFirstName()
        val ln = ctx.objectValue.getLastName()

        return when {
            fn == null && ln == null -> null
            fn == null -> ln
            ln == null -> fn
            else -> "$fn $ln"
        }
    }
}
```

### Required Selection Sets

The `@Resolver` annotation specifies which parent fields are needed:

```kotlin
@Resolver("fragment _ on User { firstName lastName }")
```

**Note:** Both positional and named parameter syntax work:
- `@Resolver("fragment _ on User { ... }")` - positional (recommended for brevity)
- `@Resolver(objectValueFragment = "fragment _ on User { ... }")` - named (more explicit)

This tells Viaduct to ensure `firstName` and `lastName` are available in `ctx.objectValue`. If you access a field not in the required selection set, you get `UnsetSelectionException` at runtime.

### Context Properties

| Property | Type | Description |
|----------|------|-------------|
| `objectValue` | `User` | The parent object (only fields in required selection set) |
| `queryValue` | `Query` | Root query object (if in required selection set) |
| `arguments` | Varies | Field arguments (if any) |
| `selections()` | `SelectionSet` | Selections on this field |

## When to Use Field Resolvers

Use `@resolver` directive when:

1. **Field has arguments**:
   ```graphql
   address(format: AddressFormat): Address @resolver
   ```

2. **Field is backed by different data source**:
   ```graphql
   firstName: String          # From User service
   lastName: String           # From User service
   wishlists: [Wishlist] @resolver  # From Wishlist service
   ```

3. **Field is computed from other fields**:
   ```graphql
   firstName: String
   lastName: String
   displayName: String @resolver  # Derived from firstName + lastName
   ```

## Code Examples

### Complete Entity Example

**Schema:**
```graphql
type Product implements Node @scope(to: ["default"]) {
  id: ID!
  name: String!
  price: Float!
  inventory: Int
  isAvailable: Boolean! @resolver
}
```

**Node Resolver:**
```kotlin
@Resolver
class ProductNodeResolver @Inject constructor(
    private val productService: ProductServiceClient
) : NodeResolvers.Product() {

    override suspend fun resolve(ctx: Context): Product {
        val data = productService.fetch(ctx.id.internalID)

        return Product.Builder(ctx)
            .name(data.name)
            .price(data.price)
            .inventory(data.inventory)
            .build()
        // Note: isAvailable has @resolver, don't set it here
    }
}
```

**Field Resolver:**
```kotlin
@Resolver("fragment _ on Product { inventory }")
class ProductIsAvailableResolver : ProductResolvers.IsAvailable() {

    override suspend fun resolve(ctx: Context): Boolean {
        val inventory = ctx.objectValue.getInventory() ?: 0
        return inventory > 0
    }
}
```

## Common Mistakes

### Setting @resolver fields in Node Resolver

```kotlin
// WRONG
return User.Builder(ctx)
    .firstName(data.firstName)
    .displayName("${data.firstName} ${data.lastName}")  // Don't do this!
    .build()

// CORRECT
return User.Builder(ctx)
    .firstName(data.firstName)
    .lastName(data.lastName)
    .build()
// Let the displayName field resolver handle it
```

### Accessing fields not in required selection set

```kotlin
// WRONG - will throw UnsetSelectionException
@Resolver("fragment _ on User { firstName }")
class DisplayNameResolver : UserResolvers.DisplayName() {
    override suspend fun resolve(ctx: Context): String? {
        val ln = ctx.objectValue.getLastName()  // Not in selection set!
        return "${ctx.objectValue.getFirstName()} $ln"
    }
}

// CORRECT
@Resolver("fragment _ on User { firstName lastName }")
class DisplayNameResolver : UserResolvers.DisplayName() {
    override suspend fun resolve(ctx: Context): String? {
        return "${ctx.objectValue.getFirstName()} ${ctx.objectValue.getLastName()}"
    }
}
```

### Forgetting to implement Node Resolver

Every type implementing `Node` must have a resolver:

```kotlin
// If you have this schema:
type Category implements Node { id: ID!, name: String! }

// You MUST implement:
class CategoryNodeResolver : NodeResolvers.Category() { ... }
```

## See Also

- [Queries](queries.md) - Query field resolvers and batch resolution
- [GlobalIDs](../gotchas/global-ids.md) - Handling GlobalIDs correctly
- [Relationships](relationships.md) - Entity relationships
